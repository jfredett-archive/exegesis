# Basic structure

A suite of raketasks (potentially hidden behind a 'exegesis' script. Adhereing
to the following model:
    
    class Project
      HAS_A Root
      HAS_MANY Directories
      HAS_MANY SourceFiles

    Responsibilities:
      Expose properties of the root directory, Spawn the initial set of
      directories which will recursively find all the files in the project

      The class will also wrap some of the SourceFile classmacros, like #join and
      #expand_path and stuff. Think along the lines of Rails.root and the like.

    Collaborators:
      Directory  
      SourceFile
    
    ----------------------------------------------------------------------------

    class Directory
      HAS_MANY SourceFiles
      HAS_MANY Directories (Children)
      HAS_A Directory (Parent)

    Responsibilities:
      Finds all the files and directories at a given level of the project
      structure, allows for recursive informing of children -- ideally in
      parallel. 

    Collaborators: 
      SourceFile
      Directory

    ----------------------------------------------------------------------------

    class SourceFile
      HAS_A Extension
      HAS_A Path
      HAS_A Base Name
      HAS_MANY SourceFiles (Dependencies)
      
    Responsibilities:
      Represents a sourcefile on disk, providing access to it's file-system
      related information as well as internal information based on the language.

    Notes:
      This will likely work w/ an inheritance heirarchy for each programming
      language. Mostly it will be one-level deep, but in the case where a
      subsequent language forms a superset/subset, deeper inheritance may occur
      (similarly we might have a module for shared subsets, etc).

    Collaborators:
      SourceFile
      SourceFileFactory       -- to build the appropriate subclass based on file extenstion

    ----------------------------------------------------------------------------
    
    class SourceFileFactory
      #snip

    Responsibilities:
      Provide an extensible way to build SourceFile instances appropriate to the
      language the source of a given file is in.

    Collaborators:
      LanguageIdentifier
      SourceFile

    ----------------------------------------------------------------------------

    class LanguageIdentifier
      #snip

    Responsibilities:
      A command object to identify the language of a given sourcefile

    Collaborators:
      SourceFileFactory

    ----------------------------------------------------------------------------

    class FileSearcher
      
    Responsibilities:
      Encapsulates an API for looking through a single directory of files,
      sorting them into directories/files/whatever, and providing those path
      lists on demand

    NB: 
      The aim is to isolate the minimum API with this class, so that alternative
      source backends could potentially be written, eg -- a backend for
      distributed sourcetrees, or w/ files in Riak or S3 or whereever

    Collaborators:
      Used By:
        Project, Directory
      Uses:
        Some system-level class like Dir, FileList, or Find
      

# Tools

Would be nice to model these guys as actors, especially so that we and make use
of that nice async stuff for a little map-reduce-y action. Celluloid? (DCell? :])

# #visit

This is an interface which would take some kind of Visitor class, which defines
up to `n` methods (on for each model type). This method would iterate over all
of it's contents (directories/files/whatever) and apply to each the appropriate
method from the visitor, with the instance as an argument. The visitor can
potentially recursively call #visit on directories, which should also support
this interface

# Features

## Core Features (Must Haves)

* Automatic Building w/ dependency discovery
  - manual configuration of dependencies also allowed
  - parallel builds by default
* Automatic Test Suite w/ boilerplate autogenerated
  - Integrates with specific tools to do this, eg, Check or CUnit, etc.
* Handles at least C, C++, and maybe Go and Rust

## Added Features (Should Haves)

* Automatic, file-system-event based recompiles.
* Integration with other Unit testing systems

## Neat Features (Could Haves)

* Statistics on code base (LOC, Complexity metrics, etc)
* Plugin API

## Far out Features (Want-to Haves)

* Language-aware search indexing (with ElasticSearch backend?)

## Random features 

* Automatically generate git helper stuff
  - spawn a repo
  - build the project skeleton
  - set up gitignore
  - set up hooks (run tests, etc)
  - Set up standard docs (README, AUTHORS, LICENSE, etc)

